"""This module provides an object for storing and processing stash scene tags
for uploading to empornium."""

from typing import Literal

import tomlkit
from tomlkit.items import AbstractTable
import utils.confighandler
import json
import re
import logging
from utils.structures import CaseInsensitiveDict
from collections.abc import MutableMapping

HAIR_COLOR_MAP = CaseInsensitiveDict(
    {
        "blonde": "blonde",
        "blond": "blonde",
        "black": "black.hair",
        "brown": "brunette",
        "brunette": "brunette",
        "red": "redhead",
        "auburn": "auburn.hair",
        "grey": "grey.hair",
    }
)

ETHNICITY_MAP = CaseInsensitiveDict(
    {
        "caucasian": "caucasian",
        "black": "black",
        "asian": "asian",
        "mixed": "mixed.race",
        "latin": "latina",
        "middle eastern": "middle.eastern",
        "indian": "indian",
    }
)


class TagHandler:
    logger: logging.Logger
    conf: utils.confighandler.ConfigHandler
    TAGS_MAP: MutableMapping[str, str] = {}
    TAG_LISTS: dict[str, list[str]] = {}
    tag_sets: dict[str, set] = {}
    countries = []
    DEMONYMS: dict[str, list[str]] = {}
    cup_sizes: dict[str, tuple[int, Literal[-1, 0, 1]]] = {}
    cup_mutex: bool

    # Dict of autogenerated tag suggestions
    tag_suggestions: CaseInsensitiveDict[str] = CaseInsensitiveDict()

    # Set of tags to apply to the current scene
    tags: set[str] = set()

    def __init__(self, conf: utils.confighandler.ConfigHandler) -> None:
        """Initialize a TagHandler object from a config object."""
        self.logger = logging.getLogger(__name__)
        self.conf = conf
        empornium = conf.items("empornium")
        self.TAGS_MAP = CaseInsensitiveDict(empornium["tags"]) if "tags" in empornium else conf.items("empornium.tags")
        for key in empornium:
            newkey = key.lower()
            if newkey == "tags":
                continue
            self.TAG_LISTS[newkey] = list(conf.get("empornium", key))  # type: ignore
            self.TAG_LISTS[newkey].sort()
            conf.set("empornium", key, self.TAG_LISTS[newkey])
            self.tag_sets[newkey] = set()
        conf.update_file()
        if "performers" in conf:
            t = conf["performers"]
            if isinstance(t, AbstractTable):
                if "cup_sizes" in t:
                    sizes = t["cup_sizes"]
                    if isinstance(sizes, AbstractTable):
                        for tag in sizes:
                            size = sizes[tag].as_string()
                            op = 0
                            if "-" in size:
                                op = -1
                            elif "+" in size:
                                op = 1
                            size = self.processTits(size)
                            self.cup_sizes[tag] = (size, op)

        assert "sex_acts" in self.TAG_LISTS
        with open("countries.json") as c:
            self.countries = json.load(c)

    def sortTagList(self, tagset: str) -> list[str]:
        """Return a sorted list for a given
        tag set name, or an empty list if
        the requested set does not exist."""
        if tagset in self.tag_sets:
            tmp = list(self.tag_sets[tagset])
            tmp.sort()
            return tmp
        return []

    def sortTagLists(self) -> dict[str, list[str]]:
        """Returns a dictionary where the keys are
        the names of custom lists and the associated
        values are the sorted lists of tags from the
        current scene."""
        return {key: self.sortTagList(key) for key in self.keys()}

    def processTag(self, tag: str) -> None:
        """Check for the appropriate EMP tag
        mapping for a provided tag and add it to
        the working lists, or generate a suggested
        mapping."""
        if "ignored_tags" in self.TAG_LISTS and tag.lower() in self.TAG_LISTS["ignored_tags"]:
            return None
        if tag in self.TAGS_MAP:
            self.tags.add(self.TAGS_MAP[tag])
        else:
            self.tag_suggestions[tag] = self.empify(tag)
        for key in self.TAG_LISTS:
            if tag in self.TAG_LISTS[key]:
                self.tag_sets[key].add(tag)

    def processPerformer(self, performer: dict) -> str:
        # also include alias tags?
        self.logger.debug(performer)
        performer_tag = self.empify(performer["name"])
        self.tags.add(performer_tag)
        gender = performer["gender"] if performer["gender"] else "FEMALE"  # Should this default be configurable?
        for tag in performer["tags"]:
            self.processTag(tag["name"])
        if len(self.countries) > 0:
            cca2 = performer["country"]
            g = "m" if (gender == "MALE" or gender == "TRANSGENDER_MALE") else "f"
            if len(cca2) > 0:
                for country in self.countries:
                    if country["cca2"] == cca2:
                        self.tags.add(self.empify(country["demonyms"]["eng"][g]))
                if cca2 in self.DEMONYMS:
                    self.logger.debug(f"Found demonyms {self.DEMONYMS[cca2]} for performer {performer['name']}")
                    self.tags.update(self.DEMONYMS[cca2])
        if "circumcised" in performer:
            if performer["circumcised"] == "CUT":
                self.tags.add("circumcised.cock")
            elif performer["circumcised"] == "UNCUT":
                self.tags.add("uncircumcised.cock")
        if self.conf["performers"]["tag_ethnicity"] and "ethnicity" in performer and performer["ethnicity"] in ETHNICITY_MAP: # type: ignore
            self.add(ETHNICITY_MAP[performer["ethnicity"]])
        if self.conf["performers"]["tag_eye_color"] and "eye_color" in performer and len(performer["eye_color"]) > 0: # type: ignore
            self.add(performer["eye_color"] + ".eyes")
        fake_tits = ""
        if "fake_tits" in performer:
            fake_tits = performer["fake_tits"].lower()
            if fake_tits == "natural":
                self.add("natural.tits")
            elif fake_tits == "augmented" or fake_tits == "fake":
                self.add("fake.tits")
        if self.conf["performers"]["tag_hair_color"] and "hair_color" in performer and performer["hair_color"] in HAIR_COLOR_MAP: # type: ignore
            self.add(HAIR_COLOR_MAP[performer["hair_color"]])
        if "measurements" in performer and len(performer["measurements"]) > 0:
            tits = self.processTits(performer["measurements"], fake_tits)
            if tits >= 0:
                for key, (value, op) in self.cup_sizes.items():
                    match op:
                        case -1:
                            if tits <= value:
                                self.add(key)
                        case 0:
                            if tits == value:
                                self.add(key)
                        case 1:
                            if tits >= value:
                                self.add(key)
        tattoos = "tattoos" in performer and len(performer["tattoos"]) > 0
        piercings = "piercings" in performer and len(performer["piercings"]) > 0
        if tattoos:
            self.add("tattoo")
            if gender.lower() == "female":
                self.add("tattooed.female")
        if piercings:
            self.add("piercings")
        if tattoos and piercings:
            self.add("tattoo.and.piercing")
        return performer_tag

    def processTits(self, measurements: str, fake_tits: str = "") -> int:
        # TODO process size/type combo tags, e.g. big.natural.tits
        cup_size = re.sub(r"[^A-Z]", "", measurements.upper())
        if cup_size == "":
            self.logger.error(f"No cup size found in {measurements}")
            return -1
        if len(cup_size) > 1:
            letter = cup_size[0]
            if cup_size != len(cup_size) * letter or (letter != "A" and letter != "D"):
                self.logger.error(f"Invalid cup size {cup_size}")
                return -1
            if letter == "A":
                return 0
            return len(cup_size) + 3
        return ord(cup_size) - 64

    def empify(self, tag: str) -> str:
        """Return an EMP-compatible tag for a given input
        tag. This function replaces all whitespace with a
        '.' and strips out all other characters that are
        not alphanumeric before finally converting the full
        string to lowercase."""
        newtag = re.sub(r"[^\w\s\.]", "", tag).lower()
        newtag = re.sub(r"\s+", ".", newtag)
        self.logger.debug(f"Reformatted tag '{tag}' to '{newtag}'")
        return newtag

    def add(self, tag: str) -> str:
        """Convert a tag to en EMP-compatible
        version and add it to the main list,
        skipping the check for custom lists.
        Returns the EMP-compatible tag."""
        tag = self.empify(tag)
        self.tags.add(tag)
        return tag

    def update_file(self) -> bool:
        updated = False
        try:
            self.conf.update_file()
            updated = True
            self.logger.debug("Saved configuration")
        except:
            pass
        return updated

    def acceptSuggestions(self, tags: MutableMapping[str, str]) -> bool:
        """Adds the provided tag mappings to the working config
        and attempts to update the config file. Returns True if
        update is successful and False otherwise."""
        self.logger.info("Saving tag mappings")
        self.logger.debug(f"Tags: {tags}")
        for tag in tags:
            self.conf.set("empornium.tags", tag.lower(), tags[tag])
            self.TAGS_MAP[tag] = tags[tag]
            if tag in self.tag_suggestions:
                self.tag_suggestions.pop(tag)
        return self.update_file()

    def rejectSuggestions(self, tags: list[str]) -> bool:
        """Adds all supplied tags to the list of ignored
        tags and attempts to update the config file. Returns
        True if update is successful and False otherwise."""
        self.logger.debug(f"Ignoring tags: {tags}")
        if "ignored_tags" not in self.TAG_LISTS:
            self.TAG_LISTS["ignored_tags"] = []
        for tag in tags:
            self.TAG_LISTS["ignored_tags"].append(tag.lower())
            if tag in self.tag_suggestions:
                self.tag_suggestions.pop(tag)
        self.TAG_LISTS["ignored_tags"].sort()
        self.conf.set("empornium", "ignored_tags", self.TAG_LISTS["ignored_tags"])
        return self.update_file()

    def keys(self) -> list[str]:
        return [key for key in self.TAG_LISTS]

    def clear(self) -> None:
        """Reset the working tag sets without
        clearing the mapping or custom list
        definitions."""
        for tagset in self.tag_sets:
            self.tag_sets[tagset].clear()
        self.tag_suggestions.clear()
        self.tags.clear()
