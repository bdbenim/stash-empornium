"""This module provides an object for storing and processing stash scene tags
for uploading to empornium."""

from typing import Literal
import os

from tomlkit.items import AbstractTable
import tomlkit
from utils.confighandler import ConfigHandler
import json
import re
import logging
from utils.customtypes import CaseInsensitiveDict
from utils.db import db, StashTag, EmpTag, get_or_create, Category
from collections.abc import MutableMapping

from flask import Flask

HAIR_COLOR_MAP = CaseInsensitiveDict(
    {
        "blonde": "blonde",
        "blond": "blonde",
        "black": "black.hair",
        "brown": "brunette",
        "brunette": "brunette",
        "red": "redhead",
        "auburn": "auburn.hair",
        "grey": "grey.hair",
    }
)

ETHNICITY_MAP = CaseInsensitiveDict(
    {
        "caucasian": "caucasian",
        "black": "black",
        "asian": "asian",
        "mixed": "mixed.race",
        "latin": "latina",
        "middle eastern": "middle.eastern",
        "indian": "indian",
    }
)

DEMONYMS: dict[str, list[str]] = {}

def empify(tag: str) -> str:
    """Return an EMP-compatible tag for a given input
    tag. This function replaces all whitespace and 
    some special characters with a '.' and strips out 
    all other characters that are not alphanumeric 
    before finally converting the full string to
    lowercase."""
    logger = logging.getLogger(__name__)
    newtag = re.sub(r"[^\w\s\._-]", "", tag).lower() #remove most special characters
    newtag = re.sub(r"[\s\._-]+", ".", newtag) # replace remaining special chars and whitespace with '.'
    newtag = newtag[:32] # truncate to max length
    logger.debug(f"Reformatted tag '{tag}' to '{newtag}'")
    return newtag

class TagHandler:
    conf: ConfigHandler
    tag_sets: dict[str, set] = {}
    countries = []
    cup_sizes: dict[str, tuple[int, Literal[-1, 0, 1]]] = {}

    def __init__(self) -> None:
        """Initialize a TagHandler object from a config object."""
        # Set of tags to apply to the current scene
        self.tags: set[str] = set()

        # Dict of autogenerated tag suggestions
        self.tag_suggestions: CaseInsensitiveDict[str] = CaseInsensitiveDict()

        self.conf: ConfigHandler = ConfigHandler()  # type: ignore
        for key in Category.query.all():
            self.tag_sets[key.name] = set()
        
        if "performers" in self.conf:
            t = self.conf["performers"]
            if isinstance(t, AbstractTable):
                if "cup_sizes" in t:
                    sizes = t["cup_sizes"]
                    if isinstance(sizes, AbstractTable):
                        for tag in sizes:
                            size = sizes[tag].as_string()
                            op = 0
                            if '-' in size or '<' in size:
                                op = -1
                            elif '+' in size or '>' in size:
                                op = 1
                            size = self.processTits(size)
                            self.cup_sizes[tag] = (size, op)

        with open("countries.json") as c:
            self.countries = json.load(c)


    def sortTagList(self, tagset: str) -> list[str]:
        """Return a sorted list for a given
        tag set name, or an empty list if
        the requested set does not exist."""
        if tagset in self.tag_sets:
            tmp = list(self.tag_sets[tagset])
            tmp.sort()
            return tmp
        return []

    def sortTagLists(self) -> dict[str, list[str]]:
        """Returns a dictionary where the keys are
        the names of custom lists and the associated
        values are the sorted lists of tags from the
        current scene."""
        return {key: self.sortTagList(key) for key in self.tag_sets}

    def processTag(self, tag: str) -> None:
        """Check for the appropriate EMP tag
        mapping for a provided tag and add it to
        the working lists, or generate a suggested
        mapping."""
        s_tag = get_or_create(StashTag, tagname=tag)
        if s_tag.ignored:
            return
        if s_tag.emp_tags:
            for e_tag in s_tag.emp_tags:
                self.tags.add(e_tag.tagname)
        else:
            self.tag_suggestions[tag] = empify(tag)
        for cat in s_tag.categories:
            self.tag_sets[cat.name].add(tag)

    def queryMaps(self, page=1, per_page=50):
        return StashTag.query.paginate(page=page, per_page=per_page)

    def processPerformer(self, performer: dict) -> str:
        # also include alias tags?
        logger = logging.getLogger(__name__)
        logger.debug(performer)
        performer_tag = empify(performer["name"])
        self.tags.add(performer_tag)
        gender = performer["gender"] if performer["gender"] else "FEMALE"  # Should this default be configurable?
        for tag in performer["tags"]:
            self.processTag(tag["name"])
        if len(self.countries) > 0:
            cca2 = performer["country"]
            g = "m" if (gender == "MALE" or gender == "TRANSGENDER_MALE") else "f"
            if len(cca2) > 0:
                for country in self.countries:
                    if country["cca2"] == cca2:
                        self.tags.add(empify(country["demonyms"]["eng"][g]))
                if cca2 in DEMONYMS:
                    logger.debug(f"Found demonyms {DEMONYMS[cca2]} for performer {performer['name']}")
                    self.tags.update(DEMONYMS[cca2])
        if "circumcised" in performer:
            if performer["circumcised"] == "CUT":
                self.tags.add("circumcised.cock")
            elif performer["circumcised"] == "UNCUT":
                self.tags.add("uncircumcised.cock")
        if gender not in ("MALE", "TRANSGENDER_MALE"):
            if self.conf["performers"]["tag_ethnicity"] and "ethnicity" in performer and performer["ethnicity"] in ETHNICITY_MAP:  # type: ignore
                self.add(ETHNICITY_MAP[performer["ethnicity"]])
            if self.conf["performers"]["tag_eye_color"] and "eye_color" in performer and len(performer["eye_color"]) > 0:  # type: ignore
                self.add(performer["eye_color"] + ".eyes")
            if self.conf["performers"]["tag_hair_color"] and "hair_color" in performer and performer["hair_color"] in HAIR_COLOR_MAP:  # type: ignore
                self.add(HAIR_COLOR_MAP[performer["hair_color"]])
            tattoos = "tattoos" in performer and len(performer["tattoos"]) > 0
            piercings = "piercings" in performer and len(performer["piercings"]) > 0
            if tattoos:
                self.add("tattoo")
                if gender.lower() == "female":
                    self.add("tattooed.female")
            if piercings:
                self.add("piercings")
            if tattoos and piercings:
                self.add("tattoo.and.piercing")
            fake_tits = ""
            if "fake_tits" in performer:
                fake_tits = performer["fake_tits"].lower()
                if fake_tits == "natural":
                    self.add("natural.tits")
                elif fake_tits == "augmented" or fake_tits == "fake":
                    self.add("fake.tits")
            if "measurements" in performer and len(performer["measurements"]) > 0:
                tits = self.processTits(performer["measurements"], fake_tits)
                if tits >= 0:
                    for key, (value, op) in self.cup_sizes.items():
                        match op:
                            case -1:
                                if tits <= value:
                                    self.add(key)
                            case 0:
                                if tits == value:
                                    self.add(key)
                            case 1:
                                if tits >= value:
                                    self.add(key)            
        return performer_tag

    def processTits(self, measurements: str, fake_tits: str = "") -> int:
        # TODO process size/type combo tags, e.g. big.natural.tits
        logger = logging.getLogger(__name__)
        cup_size = re.sub(r"[^A-Z]", "", measurements.upper())
        if cup_size == "":
            logger.error(f"No cup size found in {measurements}")
            return -1
        self.add(f"{cup_size}.cup")
        if len(cup_size) > 1:
            letter = cup_size[0]
            if cup_size != len(cup_size) * letter or (letter != "A" and letter != "D"):
                logger.error(f"Invalid cup size {cup_size}")
                return -1
            if letter == "A":
                return 0
            return len(cup_size) + 3 # DD->5, DDD->6, etc
        return ord(cup_size) - 64 # A->1, B->2, C->3, etc


    def add(self, tag: str) -> str:
        """Convert a tag to en EMP-compatible
        version and add it to the main list,
        skipping the check for custom lists.
        Returns the EMP-compatible tag."""
        tag = empify(tag)
        self.tags.add(tag)
        return tag


    def clear(self) -> None:
        """Reset the working tag sets without
        clearing the mapping or custom list
        definitions."""
        for tagset in self.tag_sets:
            self.tag_sets[tagset].clear()
        self.tag_suggestions.clear()
        self.tags.clear()

def db_init(app: Flask, tag_map: MutableMapping, tag_lists):
    logger = logging.getLogger(__name__)
    logger.info("Updating db")
    with app.app_context():
        cats: dict[str, Category] = {}
        for cat in tag_lists:
            if cat == "ignored_tags":
                continue
            cats[cat] = get_or_create(Category, name=cat)
        for st, et in tag_map.items():
            s_tag = get_or_create(StashTag, tagname=st)
            for tag in str(et).split():
                e_tag = get_or_create(EmpTag, tagname=tag)
                s_tag.emp_tags.append(e_tag)
            for cat in cats:
                if st in tag_lists[cat] or st.lower() in tag_lists[cat]:
                    s_tag.categories.append(cats[cat])
        for st in tag_lists["ignored_tags"]:
            s_tag = get_or_create(StashTag, tagname=st)
            s_tag.ignored = True
        db.session.commit()
        logger.info("Updated db")

def setup(app: Flask):
    tagstoml = os.path.join(ConfigHandler().config_dir, "tags.toml")

    with open("default-tags.toml") as f:
        conf = tomlkit.load(f)

    if os.path.exists(tagstoml):
        with open(tagstoml) as f:
            conf2 = tomlkit.load(f)
        if 'empornium.tags' in conf2:
            conf2['empornium']['tags'] = conf2["empornium.tags"] # type: ignore
        conf.update(conf2)
    
    tag_map = CaseInsensitiveDict(conf["empornium"]["tags"]) # type: ignore
    tag_lists = {}
    for lst, tags in conf["empornium"].items(): # type: ignore
        if lst == "tags":
            continue
        tag_lists[lst] = tags
    
    db_init(app, tag_map, tag_lists)

def acceptSuggestions(tags: MutableMapping[str, str]) -> None:
    """Adds the provided tag mappings to the db, 
    creating the tags as required"""
    logger = logging.getLogger(__name__)
    logger.info("Saving tag mappings")
    logger.debug(f"Tags: {tags}")
    for st,et in tags.items():
        s_tag = get_or_create(StashTag, tagname=st)
        s_tag.emp_tags.clear()
        for tag in et.split():
            s_tag.emp_tags.append(get_or_create(EmpTag, tagname=tag))
            db.session.commit()

def rejectSuggestions(tags: list[str]) -> None:
    "Marks all supplied tags as ignored"
    logger = logging.getLogger(__name__)
    logger.debug(f"Ignoring tags: {tags}")
    for tag in tags:
        s_tag = get_or_create(StashTag, tagname=tag)
        s_tag.ignored = True
        db.session.commit()